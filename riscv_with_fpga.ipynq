# Jupiter notebook
from pynq import Overlay, MMIO
import numpy as np
import time

# 1. Load the Bitstream
ol = Overlay("rv_pl.bit") 

# 2. Map the IP Blocks
# In the Dual BRAM model, you likely have two controllers
gpio_key = next(k for k in ol.ip_dict if "gpio" in k.lower())
# Find the specific names from your Vivado Block Design (e.g., instr_bram_ctrl and data_bram_ctrl)
instr_ctrl_key = next(k for k in ol.mem_dict if "instr" in k.lower())
data_ctrl_key  = next(k for k in ol.mem_dict if "data" in k.lower() or "ctrl_1" in k.lower())

gpio       = MMIO(ol.ip_dict[gpio_key]["phys_addr"], ol.ip_dict[gpio_key]["addr_range"])
instr_bram = MMIO(ol.mem_dict[instr_ctrl_key]["phys_addr"], ol.mem_dict[instr_ctrl_key]["addr_range"])
data_bram  = MMIO(ol.mem_dict[data_ctrl_key]["phys_addr"], ol.mem_dict[data_ctrl_key]["addr_range"])

# 3. Prepare the Program & Data
# Example: loading 32 signed integers
input_array = np.random.randint(-2147483648, 2147483647, size=32, dtype=np.int32)
golden_result = np.sort(input_array)

# Inject Instructions (PS -> Instruction BRAM)
# Replace this with your actual .bin/.hex parsing logic
# for i, instr in enumerate(machine_code): instr_bram.write(i*4, instr)

# Inject Data (PS -> Data BRAM)
# Array starts at 0x40 per your example
DATA_START_ADDR = 0x40 
for i, val in enumerate(input_array):
    data_bram.write(DATA_START_ADDR + i*4, int(val))

# Reset Status Flag (e.g., at 0x2000)
STATUS_ADDR = 0x2000
data_bram.write(STATUS_ADDR, 0x0)

# Release Reset via GPIO
# Using the same logic as your example (Pulse Low -> High)
gpio.write(0x4, 0x0) # Set to output
gpio.write(0x0, 0x0); time.sleep(0.02) # Reset active
gpio.write(0x0, 0x1); time.sleep(0.02) # Release reset

print("RISC-V Core is executing sorting algorithm...")

# 1. Polling the Status Flag
done = False
while not done:
    status = data_bram.read(STATUS_ADDR)
    if status in [0xCAFEBABE, 0xDEADBEAF]:
        print(f"Hardware execution complete. Status Number: {hex(status)}")
        done = True
    time.sleep(0.1)

# 2. Retrieve Results
hw_results = []
for i in range(32):
    val = data_bram.read(DATA_START_ADDR + i*4)
    # Convert unsigned to signed 32-bit
    if val >= 0x80000000:
        val -= 0x100000000
    hw_results.append(val)

# 3. Automated Checking [cite: 129]
if np.array_equal(hw_results, golden_result):
    print("Verification SUCCESS: Array is sorted correctly.")
else:
    print("Verification FAILURE: Mismatch found!")
    for i in range(32):
        if hw_results[i] != golden_result[i]:
            print(f"Index {i}: Expected {golden_result[i]}, Got {hw_results[i]}")